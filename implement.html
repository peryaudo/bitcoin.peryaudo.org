<!-- DO NOT EDIT THIS FILE, this file is generated by src/conv.rb -->

<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Bitcoinウォレットを実装する - ビットコインの仕組み：Bitcoinを技術的に徹底解説！</title>
		<meta name="description" content="Rubyを使って、Bitcoinウォレットを自分の手で実装。">
		<link rel="stylesheet" href="res/style.css">
		<link rel="alternate" type="application/rss+xml" href="http://bitcoin.peryaudo.org/index.rdf" />
        <meta name=viewport content="width=device-width, initial-scale=1">
		<script type="text/javascript">
			window.google_analytics_uacct = "UA-530611-8";
		</script>
	</head>
	<body>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-530611-8', 'peryaudo.org');
  ga('send', 'pageview');

</script>
		<div id="container">
			<div id="header">
				<h1>ビットコインの仕組み</h1>
				<a href="index.html"><img id="logo" src="res/logo.png" alt="ビットコインの仕組み"></a>
				<a href="https://github.com/peryaudo/bcwallet"><img style="position: absolute; top: 0; right: 0; border: 0;" src="res/fork_me_on_github.png" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png"></a>
			</div>
			<div id="content">
				<h2 id="bitcoinウォレットを実装する">Bitcoinウォレットを実装する</h2>

<p>Bitcoinの仕組みについてより深く解説するため、実際に筆者が簡易的なBitcoinウォレットをRubyで実装した。（<a href="https://github.com/peryaudo/bcwallet">bcwallet.rb</a>）</p>

<p>Rubyの標準ライブラリのみで書かれ、コメント・空行を除いて800行程度と、非常にコンパクトに収まったと自負している。</p>

<p>全体のソースコードはGithubにアップロードしたのでご覧頂きたい。</p>

<div class="figure"><a href = "https://github.com/peryaudo/bcwallet"><img src="res/fig_bcwallet_github.png" alt="Githubのページへ"><p class="caption">Githubのページへ</p></a></div>

<p>この章では、実際にこのクライアントのソースコードを解説しつつ、Bitcoinの仕組みについてさらに詳しく掘り下げていく。</p>

<p>Rubyに慣れていない読者もおられるかもしれないが、決してRubyとして高度な使い方をしている訳ではないのでどうかお付き合いいただきたい。</p>

<p>以下ではソースコードを引用しながら解説していくが、その全てを掲載する訳ではないので、適宜Githubの完全版を参照してほしい。</p>

<p>ダウンロードデータが小さい方が気軽にテストしやすく、また、ハッシュ木（Merkle Tree）などの概念の解説に適切であるため、このクライアントはSimplified Payment Verificationを採用することとした。</p>

<p>また、本質とあまり関係がないため、実用的なBitcoinクライアントが行わなければいけない検証の一部（とくにブロックが正しいチェーンの一部かどうか等）は省くこととした。</p>

<!--ADS-->

<div class="toc"><ul>
<li>
<a href="#bitcoinウォレットを実装する">Bitcoinウォレットを実装する</a>
<ul>
<li>
<a href="#testnet（テストネット）">Testnet（テストネット）</a>
</li>
<li>
<a href="#使われる電子署名アルゴリズムとハッシュ関数">使われる電子署名アルゴリズムとハッシュ関数</a>
</li>
<li>
<a href="#アドレスや秘密鍵の文字表現">アドレスや秘密鍵の文字表現</a>
</li>
<li>
<a href="#ブルームフィルター">ブルームフィルター</a>
</li>
<li>
<a href="#bitcoinプロトコル">Bitcoinプロトコル</a>
</li>
<li>
<a href="#ハンドシェイク（version・verack）">ハンドシェイク（version・verack）</a>
</li>
<li>
<a href="#ブルームフィルターの送信など（filterload・mempool）">ブルームフィルターの送信など（filterload・mempool）</a>
</li>
<li>
<a href="#データのハッシュの取得（getblocks）">データのハッシュの取得（getblocks）</a>
</li>
<li>
<a href="#データの取得（inv・getdata）">データの取得（inv・getdata）</a>
</li>
<li>
<a href="#トランザクションとハッシュ木ブロック（tx・merkleblock）">トランザクションとハッシュ木ブロック（tx・merkleblock）</a>
</li>
<li>
<a href="#トランザクションをもっと詳しく">トランザクションをもっと詳しく</a>
</li>
<li>
<a href="#トランザクションの作成・電子署名">トランザクションの作成・電子署名</a>
</li>
<li>
<a href="#まとめ">まとめ</a>
</li>
</ul>
</li>
</ul>
</div>

<h3 id="testnet（テストネット）">Testnet（テストネット）</h3>

<p>さっそく、bcwallet.rbのコードを読み解いていこう。</p>

<div class="CodeRay">
  <div class="code"><pre><span style="color:#777">#</span>
<span style="color:#777"># DO NOT SET THIS VALUE &quot;false&quot;.</span>
<span style="color:#777">#</span>
<span style="color:#036;font-weight:bold">IS_TESTNET</span> = <span style="color:#069">true</span>
</pre></div>
</div>


<p>Bitcoinのクライアントの開発中には、バグやセキュリティホールによってコインなどを喪失してしまう可能性がある。</p>

<p>そこで使われるのが<a href="https://en.bitcoin.it/wiki/Testnet">Testnet</a>(Bitcoin Wiki, 英語)である。Testnetはコインが実際の価値を持たないよう工夫されたBitcoinのネットワークであり、メインのネットワークからは独立している。Testnetのコインは<a href="https://tpfaucet.appspot.com/">TestNet Faucet</a>において無料で手に入れることができる。</p>

<p>また、TestnetのBlockchainは<a href="http://blockexplorer.com/testnet">TEST Bitcoin Block Explorer</a>で閲覧することができる。</p>

<p>上で公開されているBitcoinクライアントを実際に試す際にはTestnetをお使いいただきたい。</p>

<div class="tip"><p>以下、しばらくBitcoinのプロトコルの本質とあまり関係のない話（アドレスの文字列の生成方法やブルームフィルターなど）が続くので、しばらくの間ご辛抱願いたい。（退屈に思われた方は、「Bitcoinプロトコル」の節まで飛ばして頂いて構わない）</p></div>

<h3 id="使われる電子署名アルゴリズムとハッシュ関数">使われる電子署名アルゴリズムとハッシュ関数</h3>

<p>Bitcoinの電子証明には、ECDSA（楕円曲線電子署名アルゴリズム）が用いられている。本家の実装（Satoshi Nakamoto自身が実装したことからSatoshi Clientとも言う）ではOpenSSLのライブラリを使って電子署名を行っており、この実装でもOpenSSLを利用する。</p>

<p>Keyクラスは、OpenSSLライブラリを介して、楕円曲線暗号の公開鍵・秘密鍵のペアを管理するクラスである。</p>

<div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Key</span>
public
  <span style="color:#080;font-weight:bold">def</span> <span style="color:#069">self</span>.<span style="color:#06B;font-weight:bold">hash256</span>(plain)
    <span style="color:#080;font-weight:bold">return</span> <span style="color:#036;font-weight:bold">OpenSSL</span>::<span style="color:#036;font-weight:bold">Digest</span>::<span style="color:#036;font-weight:bold">SHA256</span>.digest(<span style="color:#036;font-weight:bold">OpenSSL</span>::<span style="color:#036;font-weight:bold">Digest</span>::<span style="color:#036;font-weight:bold">SHA256</span>.digest(plain))
  <span style="color:#080;font-weight:bold">end</span>

  <span style="color:#080;font-weight:bold">def</span> <span style="color:#069">self</span>.<span style="color:#06B;font-weight:bold">hash160</span>(plain)
    <span style="color:#080;font-weight:bold">return</span> <span style="color:#036;font-weight:bold">OpenSSL</span>::<span style="color:#036;font-weight:bold">Digest</span>::<span style="color:#036;font-weight:bold">RIPEMD160</span>.digest(<span style="color:#036;font-weight:bold">OpenSSL</span>::<span style="color:#036;font-weight:bold">Digest</span>::<span style="color:#036;font-weight:bold">SHA256</span>.digest(plain))
  <span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>


<p>Bitcoinではハッシュは様々な所で用いられるが、そのほとんど全てで、SHA-256を2回適用した物が使われる。しかし、より短いハッシュが必要な場合（たとえばアドレスなど）は、1回SHA-256を適用した物に、さらにもう1回RIPEMD-160を適用した物が用いられる。（上のコードの通りである）</p>

<p>以降これらを単にHash256, Hash160と呼ぶことにする。</p>

<h3 id="アドレスや秘密鍵の文字表現">アドレスや秘密鍵の文字表現</h3>

<p>Bitcoinでは、バイナリ列を人が読み書きできる形式に変換する必要がある時は、Base58が用いられる。Base58は、Base64と似ているが、書体によっては紛らわしい複数の文字や、スラッシュが取り除かれているという点でBase64と異なる。</p>

<div class="CodeRay">
  <div class="code"><pre>  <span style="color:#036;font-weight:bold">BASE58</span> = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz</span><span style="color:#710">'</span></span>
  <span style="color:#080;font-weight:bold">def</span> <span style="color:#069">self</span>.<span style="color:#06B;font-weight:bold">encode_base58</span>(plain)
    <span style="color:#777"># plain is big endian</span>

    num = plain.unpack(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">H*</span><span style="color:#710">&quot;</span></span>).first.hex

    res = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#710">'</span></span>

    <span style="color:#080;font-weight:bold">while</span> num &gt; <span style="color:#00D">0</span>
      res += <span style="color:#036;font-weight:bold">BASE58</span>[num % <span style="color:#00D">58</span>]
      num /= <span style="color:#00D">58</span>
    <span style="color:#080;font-weight:bold">end</span>

    <span style="color:#777"># restore leading zeroes</span>
    plain.each_byte <span style="color:#080;font-weight:bold">do</span> |c|
      <span style="color:#080;font-weight:bold">break</span> <span style="color:#080;font-weight:bold">if</span> c != <span style="color:#00D">0</span>
      res += <span style="color:#036;font-weight:bold">BASE58</span>[<span style="color:#00D">0</span>]
    <span style="color:#080;font-weight:bold">end</span>

    <span style="color:#080;font-weight:bold">return</span> res.reverse
  <span style="color:#080;font-weight:bold">end</span>

  <span style="color:#080;font-weight:bold">def</span> <span style="color:#069">self</span>.<span style="color:#06B;font-weight:bold">decode_base58</span>(encoded)
    num = <span style="color:#00D">0</span>
    encoded.each_char <span style="color:#080;font-weight:bold">do</span> |c|
      num *= <span style="color:#00D">58</span>
      num += <span style="color:#036;font-weight:bold">BASE58</span>.index(c)
    <span style="color:#080;font-weight:bold">end</span>

    res = num.to_s(<span style="color:#00D">16</span>)

    <span style="color:#080;font-weight:bold">if</span> res % <span style="color:#00D">2</span> == <span style="color:#00D">1</span> <span style="color:#080;font-weight:bold">then</span>
      res = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">0</span><span style="color:#710">'</span></span> + res
    <span style="color:#080;font-weight:bold">end</span>

    <span style="color:#777"># restore leading zeroes</span>
    encoded.each_char <span style="color:#080;font-weight:bold">do</span> |c|
      <span style="color:#080;font-weight:bold">break</span> <span style="color:#080;font-weight:bold">if</span> c != <span style="color:#036;font-weight:bold">BASE58</span>[<span style="color:#00D">0</span>]
      res += <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">00</span><span style="color:#710">'</span></span>
    <span style="color:#080;font-weight:bold">end</span>

    <span style="color:#080;font-weight:bold">return</span> [res].pack(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">H*</span><span style="color:#710">'</span></span>)
  <span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>


<p>Bitcoinのアドレスや秘密鍵（のエクスポート用のフォーマット）は、主データにチェックサムと種別を添えてBase58でエンコードした物である。これはSatoshi Clientにおける関数名に従って、<a href="https://en.bitcoin.it/wiki/Base58Check_encoding">Base58Check</a>と呼ばれている。</p>

<p>具体的には、「種別（1バイト）＋主データ＋「種別（1バイト）＋主データ」のHash256の頭4バイト」をBase58エンコードした物　である。</p>

<p>種別のバイトは以下の通りである。（10進数）</p>

<table><thead>
<tr>
<th>種別</th>
<th>公開鍵</th>
<th>秘密鍵</th>
</tr>
</thead><tbody>
<tr>
<td>Main</td>
<td>0</td>
<td>128</td>
</tr>
<tr>
<td>Testnet</td>
<td>111</td>
<td>239</td>
</tr>
</tbody></table>

<div class="CodeRay">
  <div class="code"><pre>  <span style="color:#080;font-weight:bold">def</span> <span style="color:#069">self</span>.<span style="color:#06B;font-weight:bold">encode_base58check</span>(type, plain)
    leading_bytes = {
      <span style="color:#A60">:main</span>    =&gt; { <span style="color:#A60">:public_key</span> =&gt; <span style="color:#00D">0</span>,   <span style="color:#A60">:private_key</span> =&gt; <span style="color:#00D">128</span> },
      <span style="color:#A60">:testnet</span> =&gt; { <span style="color:#A60">:public_key</span> =&gt; <span style="color:#00D">111</span>, <span style="color:#A60">:private_key</span> =&gt; <span style="color:#00D">239</span> }
    }

    leading_byte = [leading_bytes[<span style="color:#036;font-weight:bold">IS_TESTNET</span> ? <span style="color:#A60">:testnet</span> : <span style="color:#A60">:main</span>][type]].pack(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">C</span><span style="color:#710">'</span></span>)

    data = leading_byte + plain
    checksum = <span style="color:#036;font-weight:bold">Key</span>.hash256(data)[<span style="color:#00D">0</span>, <span style="color:#00D">4</span>]

    <span style="color:#080;font-weight:bold">return</span> <span style="color:#036;font-weight:bold">Key</span>.encode_base58(data + checksum)
  <span style="color:#080;font-weight:bold">end</span>

  <span style="color:#080;font-weight:bold">def</span> <span style="color:#069">self</span>.<span style="color:#06B;font-weight:bold">decode_base58check</span>(encoded)
    decoded = <span style="color:#036;font-weight:bold">Key</span>.decode_base58(encoded)

    raise <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">invalid base58 checksum</span><span style="color:#710">&quot;</span></span> <span style="color:#080;font-weight:bold">if</span> <span style="color:#036;font-weight:bold">Key</span>.hash256(decoded[<span style="color:#00D">0</span>, decoded.length - <span style="color:#00D">4</span>])[<span style="color:#00D">0</span>, <span style="color:#00D">4</span>] != decoded[<span style="color:#00D">-4</span>, <span style="color:#00D">4</span>]

    types = {
      <span style="color:#A60">:main</span>    =&gt; { <span style="color:#00D">0</span>   =&gt; <span style="color:#A60">:public_key</span>, <span style="color:#00D">128</span> =&gt; <span style="color:#A60">:private_key</span> },
      <span style="color:#A60">:testnet</span> =&gt; { <span style="color:#00D">111</span> =&gt; <span style="color:#A60">:public_key</span>, <span style="color:#00D">239</span> =&gt; <span style="color:#A60">:private_key</span> }
    }

    type = types[<span style="color:#036;font-weight:bold">IS_TESTNET</span> ? <span style="color:#A60">:testnet</span> : <span style="color:#A60">:main</span>][decoded[<span style="color:#00D">0</span>].unpack(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">C</span><span style="color:#710">'</span></span>).first]

    <span style="color:#080;font-weight:bold">return</span> {<span style="color:#A60">:type</span> =&gt; type, <span style="color:#A60">:data</span> =&gt; decoded[<span style="color:#00D">1</span>, decoded.length - <span style="color:#00D">5</span>]}
  <span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>


<p>Bitcoinのアドレスは、Hash160(公開鍵)をBase58Checkでエンコードした物である。</p>

<div class="CodeRay">
  <div class="code"><pre>  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">to_address_s</span>
    <span style="color:#080;font-weight:bold">return</span> <span style="color:#036;font-weight:bold">Key</span>.encode_base58check(<span style="color:#A60">:public_key</span>, <span style="color:#036;font-weight:bold">Key</span>.hash160(<span style="color:#33B">@key</span>.public_key.to_bn.to_s(<span style="color:#00D">2</span>)))
  <span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>


<h3 id="ブルームフィルター">ブルームフィルター</h3>

<div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">BloomFilter</span>
</pre></div>
</div>


<p>BloomFilterクラスは、データからブルームフィルターを構築するクラスである。</p>

<p>Simplified Payment Verification（分からない方は<a href="comparison.html">Bitcoinウォレットの比較</a>と<a href="detail.html">Bitcoinの細部</a>で復習！）はBitcoin論文で言及はされているものの、実際には、データを部分的にダウンロードする方法というのは長年存在しなかったので、これまで効率的にSPVクライアントを実装する事はできなかった。</p>

<p>しかし、<a href="https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki">BIP 0037</a>で提案されたプロトコル拡張によって、「ブルームフィルター」を用いて、自分のアドレスに関連するトランザクションのみをダウンロードしてくる事ができるようになった。</p>

<p>ブルームフィルターは、非常に高速に動作し、ある要素が集合に含まれるかどうかを、確率的に判定できるデータ構造である。「確率的」というのは、「含まれない物を、含まれると言ってしまうかもしれないが、含まれるものを含まれないと言ってしまうことはない」という特徴（つまり、偽陽性はあるが偽陰性は無い）の事を指している。</p>

<p>ブルームフィルターは極めて単純な仕組みで成り立っている。まず、フィルターは0と1のみで成り立つ（ブール値の）長さNの配列だとする。</p>

<p>あるデータに対して常に同一の、hash_funcs個の、N以下の整数を返すハッシュ関数を考える。このデータを追加する時は、このハッシュ関数の返り値と同じインデックスの配列の要素を、すべて1にすればよい。（既に1の場合そのまま）</p>

<p>あるデータが含まれるかの判定は、逆にそれらの配列の要素がすべて1であれば、「おそらく」ブルームフィルターに含まれていると言える。</p>

<p>問題は、ハッシュ関数を何とするかであるが、Bitcoinでは<a href="https://code.google.com/p/smhasher/source/browse/trunk/MurmurHash3.cpp">MurmurHash3</a>と呼ばれる非暗号的ハッシュ関数を使っている。</p>

<p>MurmurHashは、シードとデータを引数として取る。</p>

<div class="CodeRay">
  <div class="code"><pre>  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">hash</span>(seed, data)
</pre></div>
</div>


<p>Bitcoinでは、シード値を、i &lt;- [0 .. hash_funcs - 1] について、i * 0xfba4c795 + tweakで計算して、帰ってきたMurmurHashの値のmodを取って、そのビットを塗っている。（tweakは適当な乱数で、後述のfilterloadメッセージでフィルターのデータと共に送信する）</p>

<div class="CodeRay">
  <div class="code"><pre>  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">insert</span>(data)
    <span style="color:#33B">@hash_funcs</span>.times <span style="color:#080;font-weight:bold">do</span> |i|
      set_bit(hash(i * <span style="color:#00D">0xfba4c795</span> + <span style="color:#33B">@tweak</span>, data) % (<span style="color:#33B">@filter</span>.length * <span style="color:#00D">8</span>))
    <span style="color:#080;font-weight:bold">end</span>
  <span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>


<h3 id="bitcoinプロトコル">Bitcoinプロトコル</h3>

<p>いよいよ、Bitcoinのプロトコルの解説に入る。</p>

<p>Networkクラスは、実際のネットワークとの通信を扱うクラスである。</p>

<div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Network</span>
private
  <span style="color:#036;font-weight:bold">PROTOCOL_VERSION</span> = <span style="color:#00D">70001</span>
</pre></div>
</div>


<p>BitcoinはP2Pのプロトコルであるため。本来であれば、複数のノードとデータのやりとりをしなければいけないが、簡素化のため、このクライアントは一つのノードとのみ通信をすることとしている。したがって、本来であればネットワークに関係するクラスは複数必要かもしれないが、ここでは一つのみとしている。</p>

<p>Bitcoinは非同期的に相手クライアントとメッセージをやりとりすることで情報の共有をはかる。</p>

<p>メッセージの受信・送信・シリアライズを行うのは、read_message(), write_message(), serialize_message()である。</p>

<div class="CodeRay">
  <div class="code"><pre>  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">write_message</span>(message)
    <span style="color:#777"># Create payload</span>
    serialize_message(message)

    <span style="color:#777"># 4bytes: magic</span>
    raw_message = [<span style="color:#036;font-weight:bold">IS_TESTNET</span> ? <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">0b110907</span><span style="color:#710">'</span></span> : <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">f9beb4d9</span><span style="color:#710">'</span></span>].pack(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">H*</span><span style="color:#710">'</span></span>)

    <span style="color:#777"># 12bytes: command (padded with zeroes)</span>
    raw_message += [message[<span style="color:#A60">:command</span>].to_s].pack(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">a12</span><span style="color:#710">'</span></span>)

    <span style="color:#777"># 4bytes: length of payload</span>
    raw_message += [<span style="color:#33B">@payload</span>.length].pack(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">V</span><span style="color:#710">'</span></span>)

    <span style="color:#777"># 4bytes: checksum</span>
    raw_message += <span style="color:#036;font-weight:bold">Key</span>.hash256(<span style="color:#33B">@payload</span>)[<span style="color:#00D">0</span>, <span style="color:#00D">4</span>]

    <span style="color:#777"># payload</span>
    raw_message += <span style="color:#33B">@payload</span>

    <span style="color:#33B">@socket</span>.write raw_message
    <span style="color:#33B">@socket</span>.flush
  <span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>


<p>全てのメッセージは、このフォーマットに従って送信される。以降、ネットワークアドレスとOpenSSLから受け取るバイト列以外の、ほとんど全ての数値はリトル・エンディアンであることに注意。</p>

<table><thead>
<tr>
<th>バイト数</th>
<th>内容</th>
<th>解説</th>
</tr>
</thead><tbody>
<tr>
<td>4</td>
<td>マジック</td>
<td>Testnetなら0b 11 09 07、メインではf9 be b4 d9</td>
</tr>
<tr>
<td>12</td>
<td>コマンド</td>
<td>送信するコマンドのASCII文字列。<br>余ったバイトは0で埋められる。<br>（埋めていないと無視される）</td>
</tr>
<tr>
<td>4</td>
<td>ペイロードの長さ</td>
<td>送信するデータの本体の長さ</td>
</tr>
<tr>
<td>4</td>
<td>チェックサム</td>
<td>ペイロードのチェックサム、<br>Hash256した物の頭4バイト</td>
</tr>
<tr>
<td>?</td>
<td>ペイロード</td>
<td>送信するデータの本体</td>
</tr>
</tbody></table>

<p>@payloadは、メッセージを書き込む時のペイロードの配列、@r_payloadはメッセージを読み込む時のペイロードの配列である。</p>

<p>message_defs()は、メッセージの定義の一覧を返す関数であり、ラムダ式をうまく使うことで、1つの定義から「Rubyの連想配列→メッセージ（バイナリ）」と、「メッセージ（バイナリ）→Rubyの連想配列」の処理を行うことのできる仕組みとなっている。</p>

<div class="CodeRay">
  <div class="code"><pre>  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">message_defs</span>
    <span style="color:#777"># 中略</span>
    <span style="color:#080;font-weight:bold">return</span> <span style="color:#33B">@message_defs</span> = {
      <span style="color:#A60">:version</span> =&gt; [
        [<span style="color:#A60">:version</span>,   uint32],
        [<span style="color:#A60">:services</span>,  uint64],
        [<span style="color:#A60">:timestamp</span>, uint64],
        [<span style="color:#A60">:your_addr</span>, net_addr],
        [<span style="color:#A60">:my_addr</span>,   net_addr],
        [<span style="color:#A60">:nonce</span>,     uint64],
        [<span style="color:#A60">:agent</span>,     string],
        [<span style="color:#A60">:height</span>,    uint32],
        [<span style="color:#A60">:relay</span>,     relay_flag]
      ],
      <span style="color:#A60">:verack</span> =&gt; [],
      <span style="color:#A60">:mempool</span> =&gt; [],
      <span style="color:#A60">:addr</span> =&gt; [[<span style="color:#A60">:addr</span>, array.curry[net_addr]]],
      <span style="color:#A60">:inv</span>  =&gt; [[<span style="color:#A60">:inventory</span>,  array.curry[inv_vect]]],
      <span style="color:#A60">:merkleblock</span> =&gt; [
        [<span style="color:#A60">:hash</span>,        block_hash],
        [<span style="color:#A60">:version</span>,     uint32],
        [<span style="color:#A60">:prev_block</span>,  hash256],
        [<span style="color:#A60">:merkle_root</span>, hash256],
        [<span style="color:#A60">:timestamp</span>,   uint32],
        [<span style="color:#A60">:bits</span>,        uint32],
        [<span style="color:#A60">:nonce</span>,       uint32],
        [<span style="color:#A60">:total_txs</span>,   uint32],
        [<span style="color:#A60">:hashes</span>,      array.curry[hash256]],
        [<span style="color:#A60">:flags</span>,       string]
      ],
      <span style="color:#A60">:tx</span> =&gt; [
        [<span style="color:#A60">:hash</span>,      tx_hash],
        [<span style="color:#A60">:version</span>,   uint32],
        [<span style="color:#A60">:tx_in</span>,     array.curry[tx_in]],
        [<span style="color:#A60">:tx_out</span>,    array.curry[tx_out]],
        [<span style="color:#A60">:lock_time</span>, uint32]
      ],
      <span style="color:#A60">:filterload</span> =&gt; [
        [<span style="color:#A60">:filter</span>,     string],
        [<span style="color:#A60">:hash_funcs</span>, uint32],
        [<span style="color:#A60">:tweak</span>,      uint32],
        [<span style="color:#A60">:flag</span>,       uint8]
      ],
      <span style="color:#A60">:getblocks</span> =&gt; [
        [<span style="color:#A60">:version</span>,       uint32],
        [<span style="color:#A60">:block_locator</span>, array.curry[hash256]],
        [<span style="color:#A60">:hash_stop</span>,     hash256]
      ],
      <span style="color:#A60">:getdata</span> =&gt; [[<span style="color:#A60">:inventory</span>, array.curry[inv_vect]]]
    }
  <span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>


<p>それぞれの型を定義するラムダ式は、第一引数に:readをつけて呼ばれると読み込み関数、:writeをつけて呼ばれると書き込み関数として働くようになっている。</p>

<p>基本の構成要素の中で説明が必要なのはinteger型ぐらいだろうか。</p>

<div class="CodeRay">
  <div class="code"><pre>    integer = lambda <span style="color:#080;font-weight:bold">do</span> |rw, val = <span style="color:#069">nil</span>|
      <span style="color:#080;font-weight:bold">case</span> rw
      <span style="color:#080;font-weight:bold">when</span> <span style="color:#A60">:read</span>
        top = uint8.call(<span style="color:#A60">:read</span>)

        <span style="color:#080;font-weight:bold">if</span> top &lt; <span style="color:#00D">0xfd</span> <span style="color:#080;font-weight:bold">then</span>
          <span style="color:#080;font-weight:bold">return</span> top
        <span style="color:#080;font-weight:bold">elsif</span> top == <span style="color:#00D">0xfd</span> <span style="color:#080;font-weight:bold">then</span>
          <span style="color:#080;font-weight:bold">return</span> uint16.call(<span style="color:#A60">:read</span>)
        <span style="color:#080;font-weight:bold">elsif</span> top == <span style="color:#00D">0xfe</span> <span style="color:#080;font-weight:bold">then</span>
          <span style="color:#080;font-weight:bold">return</span> uint32.call(<span style="color:#A60">:read</span>)
        <span style="color:#080;font-weight:bold">elsif</span> top == <span style="color:#00D">0xff</span> <span style="color:#080;font-weight:bold">then</span>
          <span style="color:#080;font-weight:bold">return</span> uint64.call(<span style="color:#A60">:read</span>)
        <span style="color:#080;font-weight:bold">end</span>

      <span style="color:#080;font-weight:bold">when</span> <span style="color:#A60">:write</span>
        <span style="color:#080;font-weight:bold">if</span> val &lt; <span style="color:#00D">0xfd</span> <span style="color:#080;font-weight:bold">then</span>
          uint8.call(<span style="color:#A60">:write</span>, val)
        <span style="color:#080;font-weight:bold">elsif</span> val &lt;= <span style="color:#00D">0xffff</span> <span style="color:#080;font-weight:bold">then</span>
          uint8.call(<span style="color:#A60">:write</span>, <span style="color:#00D">0xfd</span>)
          uint16.call(<span style="color:#A60">:write</span>, val)
        <span style="color:#080;font-weight:bold">elsif</span> val &lt;= <span style="color:#00D">0xffffffff</span> <span style="color:#080;font-weight:bold">then</span>
          uint8.call(<span style="color:#A60">:write</span>, <span style="color:#00D">0xfe</span>)
          uint32.call(<span style="color:#A60">:write</span>, val)
        <span style="color:#080;font-weight:bold">else</span>
          uint8.call(<span style="color:#A60">:write</span>, <span style="color:#00D">0xff</span>)
          uint64.call(<span style="color:#A60">:write</span>, val)
        <span style="color:#080;font-weight:bold">end</span>

      <span style="color:#080;font-weight:bold">end</span>
    <span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>


<p>integer型は可変長の符号なし整数であり、先頭のバイトによって長さが示される。この型は、Bitcoin Wikiなどの資料では、var_int型と呼ばれている。</p>

<ul>
<li>0xfdより小さい→先頭のバイトそのものが値で、1バイト(8bit)</li>
<li>0xfd→その直後の2バイト(16bit)</li>
<li>0xfe→その直後の4バイト(32bit)</li>
<li>0xff→その直後の8バイト(64bit)</li>
</ul>

<p>string型は、先頭のinteger型で以降に続く文字列の長さが示されている、可変長の文字列型である。</p>

<h3 id="ハンドシェイク（version・verack）">ハンドシェイク（version・verack）</h3>

<div class="CodeRay">
  <div class="code"><pre><span style="color:#606">Usage</span>: ruby bcwallet.rb &lt;command&gt; [&lt;args&gt;]
<span style="color:#606">commands</span>:
    generate &lt;name&gt;             generate a new <span style="color:#036;font-weight:bold">Bitcoin</span> address
    list                        show list <span style="color:#080;font-weight:bold">for</span> all <span style="color:#036;font-weight:bold">Bitcoin</span> addresses
    export &lt;name&gt;               show private key <span style="color:#080;font-weight:bold">for</span> the <span style="color:#036;font-weight:bold">Bitcoin</span> address
    balance                     show balances <span style="color:#080;font-weight:bold">for</span> all <span style="color:#036;font-weight:bold">Bitcoin</span> addresses
    send &lt;name&gt; &lt;to&gt; &lt;amount&gt;   transfer coins to the <span style="color:#036;font-weight:bold">Bitcoin</span> address
</pre></div>
</div>


<p>上記はbcwallet.rbを無引数で起動した時のUsageである。bcwallet.rbはruby bcwallet.rb balanceとして実行されると、自動的にブロックチェーンの同期をはじめる。この時のプログラムの流れを順に追っていこう。</p>

<div class="CodeRay">
  <div class="code"><pre><span style="color:#777"># BCWallet#run</span>
    <span style="color:#080;font-weight:bold">when</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">balance</span><span style="color:#710">'</span></span>
      <span style="color:#069">STDERR</span>.print <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">loading data ...</span><span style="color:#b0b">\r</span><span style="color:#710">&quot;</span></span>
      <span style="color:#33B">@network</span> = <span style="color:#036;font-weight:bold">Network</span>.new(<span style="color:#33B">@keys</span>, <span style="color:#33B">@data_file_name</span>)

      <span style="color:#33B">@network</span>.sync()

      wait_for_sync()

      puts <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Balances for available Bitcoin addresses: </span><span style="color:#710">'</span></span>

      balance = <span style="color:#33B">@network</span>.get_balance()
      balance.each <span style="color:#080;font-weight:bold">do</span> |addr, satoshi|
        puts <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">    </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">#{</span> addr <span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20">: </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">#{</span> sprintf(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">%.8f</span><span style="color:#710">'</span></span>, Rational(satoshi, <span style="color:#00D">10</span>**<span style="color:#00D">8</span>)) <span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20"> BTC</span><span style="color:#710">&quot;</span></span>
      <span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>


<p>BCWalletクラスはコマンドライン引数を処理し、同ディレクトリの鍵ファイル（Testnetならkeys_testnet、でなければkeys）を読んだ上で、鍵データを渡してNetworkクラスを作成し、Network#syncを実行する。</p>

<p>Network#sync()はネットワーク通信用のスレッドを新たに作成した上で、直ちにプログラムに戻る。そこで、BCWalletクラス側では、Network#sync_finished?がtrueになるのを、sleepをはさんでひたすら待ち続けながら、Network#statusの内容を画面に表示する(wait_for_sync())。同期が終了したら、Network#get_balance()で残高のデータを得て、それを画面に表示する。</p>

<div class="CodeRay">
  <div class="code"><pre>  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">sync</span>
    <span style="color:#036;font-weight:bold">Thread</span>.abort_on_exception = <span style="color:#069">true</span>
    <span style="color:#33B">@is_sync_finished</span> = <span style="color:#069">false</span>
    t = <span style="color:#036;font-weight:bold">Thread</span>.new <span style="color:#080;font-weight:bold">do</span>

      <span style="color:#080;font-weight:bold">unless</span> <span style="color:#33B">@socket</span> <span style="color:#080;font-weight:bold">then</span>
        <span style="color:#33B">@status</span> = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">connection establishing ... </span><span style="color:#710">'</span></span>

        <span style="color:#33B">@socket</span> = <span style="color:#036;font-weight:bold">TCPSocket</span>.open(<span style="color:#036;font-weight:bold">HOST</span>, <span style="color:#036;font-weight:bold">IS_TESTNET</span> ? <span style="color:#00D">18333</span> : <span style="color:#00D">8333</span>)

        send_version()
      <span style="color:#080;font-weight:bold">end</span>

      <span style="color:#080;font-weight:bold">if</span> <span style="color:#33B">@created_transaction</span> <span style="color:#080;font-weight:bold">then</span>
        <span style="color:#33B">@status</span> = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">announcing transaction ... </span><span style="color:#710">'</span></span>

        send_transaction_inv()
      <span style="color:#080;font-weight:bold">end</span>

      loop <span style="color:#080;font-weight:bold">do</span>
        <span style="color:#080;font-weight:bold">break</span> <span style="color:#080;font-weight:bold">if</span> dispatch_message()
      <span style="color:#080;font-weight:bold">end</span>

      <span style="color:#33B">@is_sync_finished</span> = <span style="color:#069">true</span>
    <span style="color:#080;font-weight:bold">end</span>
    t.run
  <span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>


<p>他のアドレスに向かってコインを振り込む時は、Network#sendで送信先や金額などを指定してから、同様にNetwork#syncする（後述）。@created_transactionはNetwork#sendがセットする変数である。</p>

<p>syncが呼ばれた時、ソケットが存在しない場合、ただちにHOSTに接続して（Testnetならポート18333、Mainなら8333）、バージョンメッセージを送信し(send_version())、メッセージループに入る(dispatch_message())。メッセージループは、これ以上メッセージを受信する必要のない時にtrueを返す。</p>

<div class="tip"><p>HOSTはデフォルトではlocalhostである。bcwallet.rbのような、ルールを守らないクライアントが外のノードと通信するとよくないと思うので、極力自分のところでBitcoin-Qtを-testnetで起動した所につないで遊んでもらいたい。</p><p>Satoshi Clientの初期ノード探索は、若いバージョンの頃はIRCを用いた「面白い」物となっていたが、今は開発者の立てているノードにつなぎに行ってそこからaddrメッセージを受け取るだけなので特筆すべき点はない。</p><p>話は脱線するが、Satoshi Nakamotoが言及する技術はIRCやUsenet、それにハードディスクの容量を論文で気にしていたりと、総合して見ると明らかに数世代以上前の感があり、さらにはSatoshi ClientのソースはシステムハンガリアンでC++なのにvectorに頻繁にmemcpyしていたりなど、いかにもかなり昔からこの世界に居る技術者っぽさが漂っているが、読者の方々はいかが思われるだろうか。こういった点から謎の人物について思いをはせるのも良いのかもしれない。</p></div>

<div class="CodeRay">
  <div class="code"><pre>  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">dispatch_message</span>
    message = read_message()

    <span style="color:#080;font-weight:bold">case</span> message[<span style="color:#A60">:command</span>]
    <span style="color:#080;font-weight:bold">when</span> <span style="color:#A60">:version</span>
      <span style="color:#777"># 最後のブロックの高さ</span>
      <span style="color:#33B">@data</span>[<span style="color:#A60">:last_height</span>] = message[<span style="color:#A60">:height</span>]
      save_data

      write_message({<span style="color:#A60">:command</span> =&gt; <span style="color:#A60">:verack</span>})

    <span style="color:#080;font-weight:bold">when</span> <span style="color:#A60">:verack</span>
      <span style="color:#777"># ハンドシェイク完了</span>
</pre></div>
</div>


<p>ハンドシェイクの手順は以下の通りである。（<a href="https://en.bitcoin.it/wiki/Version_Handshake">Bitcoin Wikiの記述</a>）</p>

<ul>
<li>接続者(A)がまずversionメッセージを接続先(B)に送信（そうするまで被接続者は何も送ってこない）</li>
<li>A←B versionメッセージを送り返す（プロトコルのバージョンを二者のうち小さい方にあわせる）</li>
<li>A→B versionメッセージの内容を確認してverackを送り返す</li>
<li>A←B verackを送り返す</li>
</ul>

<p>versionメッセージには以下のような情報が含まれている。
verackは、ボディー（ペイロード）が無く、メッセージ名だけのメッセージである。</p>

<div class="CodeRay">
  <div class="code"><pre>  <span style="color:#777"># message_defs()</span>
      <span style="color:#A60">:version</span> =&gt; [
        [<span style="color:#A60">:version</span>,   uint32],
        [<span style="color:#A60">:services</span>,  uint64],
        [<span style="color:#A60">:timestamp</span>, uint64],
        [<span style="color:#A60">:your_addr</span>, net_addr],
        [<span style="color:#A60">:my_addr</span>,   net_addr],
        [<span style="color:#A60">:nonce</span>,     uint64],
        [<span style="color:#A60">:agent</span>,     string],
        [<span style="color:#A60">:height</span>,    uint32],
        [<span style="color:#A60">:relay</span>,     relay_flag]
      ],
      <span style="color:#A60">:verack</span> =&gt; [],

  <span style="color:#777"># 中略</span>

  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">send_version</span>
    write_message({
      <span style="color:#A60">:command</span> =&gt; <span style="color:#A60">:version</span>,

      <span style="color:#A60">:version</span>   =&gt; <span style="color:#036;font-weight:bold">PROTOCOL_VERSION</span>,

      <span style="color:#777"># 完全なブロックを相手に送れないので0</span>
      <span style="color:#A60">:services</span>  =&gt; <span style="color:#00D">0</span>,

      <span style="color:#A60">:timestamp</span> =&gt; <span style="color:#036;font-weight:bold">Time</span>.now.to_i,

      <span style="color:#A60">:your_addr</span> =&gt; <span style="color:#069">nil</span>, <span style="color:#777"># 本当はちゃんと書かないといけないけどテキトーでも</span>
      <span style="color:#A60">:my_addr</span>   =&gt; <span style="color:#069">nil</span>, <span style="color:#777"># 相手クライアントから怒られないから省略</span>

      <span style="color:#A60">:nonce</span>     =&gt; (rand(<span style="color:#00D">1</span> &lt;&lt; <span style="color:#00D">64</span>) - <span style="color:#00D">1</span>), <span style="color:#777"># A random number.</span>

      <span style="color:#A60">:agent</span>     =&gt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">/bcwallet.rb:1.00/</span><span style="color:#710">'</span></span>, <span style="color:#777"># エージェントの名前</span>
      <span style="color:#A60">:height</span>    =&gt; (<span style="color:#33B">@data</span>[<span style="color:#A60">:blocks</span>].length - <span style="color:#00D">1</span>), <span style="color:#777"># 所持しているブロックの高さ</span>

      <span style="color:#777"># filterloadするまでいかなるinvも送信しない</span>
      <span style="color:#A60">:relay</span>     =&gt; <span style="color:#069">false</span>
    })

    <span style="color:#080;font-weight:bold">return</span>
  <span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>


<p>versionメッセージの内容はかなり適当でもあまりSatoshi Clientは弾き返したりしないようであるが、relayフラグだけは重要である。</p>

<p>relayフラグは、上でも述べたBIP 0037で追加されたフラグである。</p>

<p>Bitcoinは全てのトランザクションのデータをブロードキャストで全てのノードに伝言していくが、これは、相手クライアントの意志と関係なくinvメッセージでハッシュを送り、相手クライアントがそれに対してgetdataを送り返す事で実現されている（後述）。relayフラグを0にセットしないと、相手クライアントはたちまち大量の自分と関係のないinvメッセージを送りつけてくる。</p>

<p>これは、SPVクライアントの望んでいる事ではないので、relayフラグをfalseにセットすることで、filterloadでブルームフィルターをセットするまで全てのinvの送信を止めさせることができる。（そしてfilterloadをセットした後はブルームフィルターに一致したinvしか送られてこない）</p>

<div class="tip"><p><strong>何故bcwallet.rbは他のSPVクライアントより遅いのか</strong> 上のbcwallet.rbを実際に試して頂いた方で、MultiBitなどの他のSPVのBitcoinクライアントを使ったことのある方は、どうしてbcwallet.rbの初回起動時の同期は遅いのかと思われた方も居るかもしれない。</p><p>これは、他のSPVクライアントは、アドレスの作成日時・作成時点での最終ブロックなどの情報を用いて、それより前のブロックのダウンロードを省いているからである。bcwallet.rbは教育用であり、このような複雑な処理を省いて単純化をはかる代わり、はじめに全てのブロックをダウンロードしている。</p></div>

<h3 id="ブルームフィルターの送信など（filterload・mempool）">ブルームフィルターの送信など（filterload・mempool）</h3>

<p>引き続き、ハンドシェイク後の動作を見ていこう。</p>

<div class="CodeRay">
  <div class="code"><pre>    <span style="color:#080;font-weight:bold">when</span> <span style="color:#A60">:verack</span>
      <span style="color:#777"># ハンドシェイク完了</span>

      <span style="color:#777"># ブルームフィルターをセット</span>
      send_filterload()

      <span style="color:#777"># メモリープール内のトランザクションを勝手にinvするように</span>
      write_message({<span style="color:#A60">:command</span> =&gt; <span style="color:#A60">:mempool</span>})

      <span style="color:#777"># 必要ならばgetblocksを送って、もう終わりならtrueを返す。</span>
      <span style="color:#080;font-weight:bold">return</span> <span style="color:#069">true</span> <span style="color:#080;font-weight:bold">if</span> send_getblocks()
</pre></div>
</div>


<p>send_filterload()の中は以下の通りである。filterloadコマンドにより、相手クライアントにブルームフィルターのデータを送信し、このフィルターに一致したデータしか送ってこないようにすることができる。</p>

<div class="CodeRay">
  <div class="code"><pre>          <span style="color:#777"># message_defs</span>
          <span style="color:#A60">:filterload</span> =&gt; [
            [<span style="color:#A60">:filter</span>,     string],
            [<span style="color:#A60">:hash_funcs</span>, uint32],
            [<span style="color:#A60">:tweak</span>,      uint32],
            [<span style="color:#A60">:flag</span>,       uint8]
          ],

   <span style="color:#777"># 中略</span>

   <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">send_filterload</span>
    hash_funcs = <span style="color:#00D">10</span>
    tweak = rand(<span style="color:#00D">1</span> &lt;&lt; <span style="color:#00D">32</span>) - <span style="color:#00D">1</span>

    bf = <span style="color:#036;font-weight:bold">BloomFilter</span>.new(<span style="color:#00D">512</span>, hash_funcs, tweak) 

    <span style="color:#33B">@keys</span>.each <span style="color:#080;font-weight:bold">do</span> |_, key|
      bf.insert(key.to_public_key)
      bf.insert(key.to_public_key_hash)
    <span style="color:#080;font-weight:bold">end</span>

    write_message({
      <span style="color:#A60">:command</span> =&gt; <span style="color:#A60">:filterload</span>,

      <span style="color:#A60">:filter</span>     =&gt; bf.to_s,
      <span style="color:#A60">:hash_funcs</span> =&gt; hash_funcs,
      <span style="color:#A60">:tweak</span>      =&gt; tweak,

      <span style="color:#777"># BLOOM_UPDATE_ALL, updates Bloom filter automatically when the client has found matching transactions.</span>
      <span style="color:#A60">:flag</span>       =&gt; <span style="color:#00D">1</span>
    })
  <span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>


<p>先に説明したBloomFilterクラスに、所持している鍵の、公開鍵・公開鍵のハッシュを登録していく。</p>

<p>hash_funcsとBloomFilterのサイズは数学的に効率的となる計算方法が存在するが、ここでは割愛した。興味のある読者は、<a href="https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki">BIP 0037</a>に明確な記述があり、また<a href="https://code.google.com/p/bitcoinj/">bitcoinj</a>のソースコードが参考になるだろう。フィルターサイズの上限は36000バイトである事に注意。フィルターのデータはstring型であり先頭にvar_intで長さが付加されるのにも注意。</p>

<p>flagも重要である。これは、マッチしたトランザクションに関連するデータを、先方のクライアントが自動で追加していくオプションである。これがないと、仮にアドレスだけをブルームフィルターに登録した際、自分のアドレスがコインを受け取ったトランザクションは引っかかるが、自分のアドレスがコインを消費したトランザクションはフィルターにマッチしない、従って正しい自分のアドレスの残高を割り出せない、といった事態が起こりうる。</p>

<p>mempoolは先方のメモリープールに含まれるトランザクションのinvを自動で送らせるコマンドである。
これにより未承認のトランザクションのデータをすばやく受け取ることができる。</p>

<h3 id="データのハッシュの取得（getblocks）">データのハッシュの取得（getblocks）</h3>

<p>getblocksは、自分の所持していないブロック（とそれに関連するトランザクション）のinvを要求するメソッドである。
受信したブロック数が、相手のversionメッセージに書いてあった、相手の所持している最終ブロックの番号を超えたら、send_getblocksはtrueを返し、止まるようにする。</p>

<div class="CodeRay">
  <div class="code"><pre>      <span style="color:#777"># message_defs</span>
      <span style="color:#A60">:getblocks</span> =&gt; [
        [<span style="color:#A60">:version</span>,       uint32],
        [<span style="color:#A60">:block_locator</span>, array.curry[hash256]],
        [<span style="color:#A60">:hash_stop</span>,     hash256]
      ],

  <span style="color:#777"># 中略</span>

  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">send_getblocks</span>
    weight = <span style="color:#00D">50</span>
    perc = (weight * <span style="color:#33B">@data</span>[<span style="color:#A60">:blocks</span>].length / <span style="color:#33B">@data</span>[<span style="color:#A60">:last_height</span>]).to_i
    <span style="color:#33B">@status</span> = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">|</span><span style="color:#710">'</span></span> + <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">=</span><span style="color:#710">'</span></span> * perc + <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">_</span><span style="color:#710">'</span></span> * (weight - perc) +
      <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">| </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">#{</span>(<span style="color:#33B">@data</span>[<span style="color:#A60">:blocks</span>].length - <span style="color:#00D">1</span>)<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20"> / </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">#{</span><span style="color:#33B">@data</span>[<span style="color:#A60">:last_height</span>]<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20"> </span><span style="color:#710">&quot;</span></span>

    <span style="color:#777"># @data[:blocks].length includes block #0 while @data[:last_height] does not.</span>
    <span style="color:#080;font-weight:bold">if</span> <span style="color:#33B">@data</span>[<span style="color:#A60">:blocks</span>].length &gt; <span style="color:#33B">@data</span>[<span style="color:#A60">:last_height</span>] <span style="color:#080;font-weight:bold">then</span>
      save_data()
      <span style="color:#080;font-weight:bold">return</span> <span style="color:#069">true</span>
    <span style="color:#080;font-weight:bold">end</span>

    <span style="color:#080;font-weight:bold">if</span> <span style="color:#33B">@data</span>[<span style="color:#A60">:blocks</span>].empty? <span style="color:#080;font-weight:bold">then</span>
      send_getdata([{<span style="color:#A60">:type</span> =&gt; <span style="color:#036;font-weight:bold">MSG_FILTERED_BLOCK</span>, <span style="color:#A60">:hash</span> =&gt; <span style="color:#33B">@last_hash</span>[<span style="color:#A60">:hash</span>]}])
    <span style="color:#080;font-weight:bold">end</span>

    write_message({
      <span style="color:#A60">:command</span> =&gt; <span style="color:#A60">:getblocks</span>,

      <span style="color:#A60">:version</span> =&gt; <span style="color:#036;font-weight:bold">PROTOCOL_VERSION</span>,
      <span style="color:#A60">:block_locator</span> =&gt; [<span style="color:#33B">@last_hash</span>[<span style="color:#A60">:hash</span>]],
      <span style="color:#A60">:hash_stop</span> =&gt; [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">00</span><span style="color:#710">'</span></span> * <span style="color:#00D">32</span>].pack(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">H*</span><span style="color:#710">'</span></span>)
    })

    <span style="color:#080;font-weight:bold">return</span> <span style="color:#069">false</span>
  <span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>


<p>block_locatorは自分の所持している最終ブロックのハッシュを指定する。
hash_stopは、ここまでで送信をストップする、というブロックのハッシュを指定する。(0を指定した場合は500個までinvしてくる）</p>

<p>block_locatorはここでは1つのハッシュのみを渡すように使われているが、配列である事からも分かるように、実際にはそれよりはるかに複雑な仕組みである。</p>

<p>block_locatorは本来、自分の信じているブロックチェーンが正しい分岐をたどっているかを抜き打ち検査的にチェックする仕組みである。以下の（現在の版のbcwallet.rbには含まれない）コードをみて欲しい。</p>

<div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">generate_block_locator_indices</span>(height)
  res = []

  step = <span style="color:#00D">1</span>
  <span style="color:#080;font-weight:bold">while</span> height &gt; <span style="color:#00D">0</span>
    step *= <span style="color:#00D">2</span> <span style="color:#080;font-weight:bold">if</span> res.length &gt;= <span style="color:#00D">10</span>
    res.push height
    height -= step
  <span style="color:#080;font-weight:bold">end</span>

  res.push <span style="color:#00D">0</span>

  <span style="color:#080;font-weight:bold">return</span> res
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>


<p>あなたが持っている中で最後のブロックの高さ（つまり、genesis block（最初のブロック）から数えた番号）がheightだとして、本来block_locatorは、generate_block_locator_indices()の指し示す高さのブロックのハッシュを、全て含まなければならない。</p>

<p>と、言われてもよく分からないだろうが、小さい数でテストしてみよう。height = 500とする。</p>

<div class="CodeRay">
  <div class="code"><pre>&gt; generate_block_locator_indices(<span style="color:#00D">500</span>)
=&gt; [<span style="color:#00D">500</span>, <span style="color:#00D">499</span>, <span style="color:#00D">498</span>, <span style="color:#00D">497</span>, <span style="color:#00D">496</span>, <span style="color:#00D">495</span>, <span style="color:#00D">494</span>, <span style="color:#00D">493</span>, <span style="color:#00D">492</span>, <span style="color:#00D">491</span>, <span style="color:#00D">490</span>, <span style="color:#00D">488</span>, <span style="color:#00D">484</span>, <span style="color:#00D">476</span>, <span style="color:#00D">460</span>, <span style="color:#00D">428</span>, <span style="color:#00D">364</span>, <span style="color:#00D">236</span>, <span style="color:#00D">0</span>]
</pre></div>
</div>


<p>500番目、499番目、498番目…と順に番号が下っていく中で、10個を超えると指数関数的に番号が下っていく。（Bitcoin Wikiでは「最初は濃く、次第にまばらに」と表現されている）</p>

<p>これにより、少ない個数のハッシュで、効果的に自分の居るブロックチェーンの分岐の位置を相手に伝えることができる。相手クライアントは、こちら側が誤ったブランチに居る事が分かれば、block_locatorの内容は無視して1番目のブロックからの情報をこちらに返す。</p>

<h3 id="データの取得（inv・getdata）">データの取得（inv・getdata）</h3>

<p>Bitcoinは御存知の通りP2Pの仕組みを取っているため、サーバー・クライアントモデルのような、誰が誰に情報を教えると言った役割分担は存在しない。したがって、任意のクライアントが任意のクライアントに自分の持っている情報を教えうるわけであるが、情報を教えるにあたって、相手がその情報を既に知っているかどうかにかかわらず、常に情報全体を送信していたら、ネットワークはたちまちパンクしてしまうだろう。したがってBitcoinでは、情報の本体を送信する前に、そのハッシュをinvメッセージとして相手クライアントに送り、相手クライアント側から必要な時にはgetdataメッセージを送って情報の本体を要求するという手順を取る。</p>

<div class="CodeRay">
  <div class="code"><pre>    inv_vect = lambda <span style="color:#080;font-weight:bold">do</span> |rw, val = <span style="color:#069">nil</span>|
      <span style="color:#080;font-weight:bold">case</span> rw
      <span style="color:#080;font-weight:bold">when</span> <span style="color:#A60">:read</span>
        type = uint32.call(<span style="color:#A60">:read</span>)
        hash = hash256.call(<span style="color:#A60">:read</span>)
        <span style="color:#080;font-weight:bold">return</span> {<span style="color:#A60">:type</span> =&gt; type, <span style="color:#A60">:hash</span> =&gt; hash}
      <span style="color:#080;font-weight:bold">when</span> <span style="color:#A60">:write</span>
        uint32.call(<span style="color:#A60">:write</span>, val[<span style="color:#A60">:type</span>])
        hash256.call(<span style="color:#A60">:write</span>, val[<span style="color:#A60">:hash</span>])
      <span style="color:#080;font-weight:bold">end</span>
    <span style="color:#080;font-weight:bold">end</span>

  <span style="color:#777"># 中略</span>

      <span style="color:#A60">:inv</span>  =&gt; [[<span style="color:#A60">:inventory</span>,  array.curry[inv_vect]]],
      <span style="color:#A60">:getdata</span> =&gt; [[<span style="color:#A60">:inventory</span>, array.curry[inv_vect]]]

  <span style="color:#777"># 中略</span>

  <span style="color:#036;font-weight:bold">MSG_TX</span> = <span style="color:#00D">1</span>
  <span style="color:#036;font-weight:bold">MSG_BLOCK</span> = <span style="color:#00D">2</span>
  <span style="color:#036;font-weight:bold">MSG_FILTERED_BLOCK</span> = <span style="color:#00D">3</span>

  <span style="color:#777"># 中略</span>
    <span style="color:#080;font-weight:bold">when</span> <span style="color:#A60">:inv</span>
      send_getdata message[<span style="color:#A60">:inventory</span>]

  <span style="color:#777"># 全部のデータを受け取ったか判定できるように、送ったgetdataの数を覚えておく</span>
      <span style="color:#33B">@requested_data</span> += message[<span style="color:#A60">:inventory</span>].length

  <span style="color:#777"># 中略</span>

  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">send_getdata</span>(inventory)
    write_message({
      <span style="color:#A60">:command</span> =&gt; <span style="color:#A60">:getdata</span>,

      <span style="color:#A60">:inventory</span> =&gt; inventory.collect <span style="color:#080;font-weight:bold">do</span> |elm|
        <span style="color:#777"># receive merkleblock instead of usual block</span>
        {<span style="color:#A60">:type</span> =&gt; (elm[<span style="color:#A60">:type</span>] == <span style="color:#036;font-weight:bold">MSG_BLOCK</span> ? <span style="color:#036;font-weight:bold">MSG_FILTERED_BLOCK</span> : elm[<span style="color:#A60">:type</span>]),
         <span style="color:#A60">:hash</span> =&gt; elm[<span style="color:#A60">:hash</span>]}
      <span style="color:#080;font-weight:bold">end</span>
    })

    <span style="color:#080;font-weight:bold">return</span>
  <span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>


<p>様々な所からコードを抜粋した。invもgetdataも本体はinv_vectの配列である。inv_vectはデータのハッシュ値とデータのタイプを含む。
データのタイプには、MSG_TXとMSG_BLOCK、およびBIP0037で追加されたMSG_FILTERED_BLOCKが存在する。
MSG_TXはtx、MSG_BLOCKはblockを返すのに対して、MSG_FILTERED_BLOCKはmerkleblockを返す。merkleblockは、後述するように、ブルームフィルターに一致したトランザクションを検証するのに必要な、ハッシュ木のノードの情報を含んだブロックで、やはりBIP0037で定義されたメッセージである。</p>

<h3 id="トランザクションとハッシュ木ブロック（tx・merkleblock）">トランザクションとハッシュ木ブロック（tx・merkleblock）</h3>

<p>getdataによってtxメッセージやmerkleblockメッセージを受信する。</p>

<div class="CodeRay">
  <div class="code"><pre>      <span style="color:#A60">:merkleblock</span> =&gt; [
        [<span style="color:#A60">:hash</span>,        block_hash],
        [<span style="color:#A60">:version</span>,     uint32],
        [<span style="color:#A60">:prev_block</span>,  hash256],
        [<span style="color:#A60">:merkle_root</span>, hash256],
        [<span style="color:#A60">:timestamp</span>,   uint32],
        [<span style="color:#A60">:bits</span>,        uint32],
        [<span style="color:#A60">:nonce</span>,       uint32],
        [<span style="color:#A60">:total_txs</span>,   uint32],
        [<span style="color:#A60">:hashes</span>,      array.curry[hash256]],
        [<span style="color:#A60">:flags</span>,       string]
      ],
      <span style="color:#A60">:tx</span> =&gt; [
        [<span style="color:#A60">:hash</span>,      tx_hash],
        [<span style="color:#A60">:version</span>,   uint32],
        [<span style="color:#A60">:tx_in</span>,     array.curry[tx_in]],
        [<span style="color:#A60">:tx_out</span>,    array.curry[tx_out]],
        [<span style="color:#A60">:lock_time</span>, uint32]
      ],
</pre></div>
</div>


<p>ここで、ブロックとトランザクションのハッシュの計算方法を確認しておきたい。:hashは、write_messageの時には単純に無視され、read_messageで作成される、仮想的な要素である。</p>

<p>block_hashやtx_hashの実装はこのようになっている。</p>

<div class="CodeRay">
  <div class="code"><pre>    block_hash = lambda <span style="color:#080;font-weight:bold">do</span> |rw, val = <span style="color:#069">nil</span>|
      <span style="color:#080;font-weight:bold">case</span> rw
      <span style="color:#080;font-weight:bold">when</span> <span style="color:#A60">:read</span>
        <span style="color:#080;font-weight:bold">return</span> <span style="color:#036;font-weight:bold">Key</span>.hash256(<span style="color:#33B">@r_payload</span>[<span style="color:#00D">0</span>, <span style="color:#00D">80</span>])
      <span style="color:#080;font-weight:bold">end</span>
    <span style="color:#080;font-weight:bold">end</span>

    tx_hash = lambda <span style="color:#080;font-weight:bold">do</span> |rw, val = <span style="color:#069">nil</span>|
      <span style="color:#080;font-weight:bold">case</span> rw
      <span style="color:#080;font-weight:bold">when</span> <span style="color:#A60">:read</span>
        <span style="color:#080;font-weight:bold">return</span> <span style="color:#036;font-weight:bold">Key</span>.hash256(<span style="color:#33B">@r_payload</span>)
      <span style="color:#080;font-weight:bold">end</span>
    <span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>


<p>txのハッシュは単純にトランザクションのデータ全体についてのハッシュだが、block・merkeblockなどのハッシュは、そのうちのヘッダー部分、つまり先頭80バイトの、nonceまでだけのハッシュである事に注意する。</p>

<p>このブロックのハッシュが<a href="design.html">Bitcoinの仕組み</a>でも述べたproof-of-workに使われるハッシュである。実際のデータではリトル・エンディアンで配置されているが、.reverseしてunpackするとたしかに00000abc....といった風なハッシュ値が見えてくる。</p>

<p>（ブロックを用いたトランザクションの検証についてはbcwallet.rbの実装と共に加筆予定）</p>

<p>txのlock_timeは現在のバージョンでは使われていない物で、今は常に0である。
versionはPROTOCOL_VERSIONとも異なる何らかのバージョンである。</p>

<h3 id="トランザクションをもっと詳しく">トランザクションをもっと詳しく</h3>

<p>そろそろ、トランザクションの作成にも多少意識を向けつつ、tx_inとtx_outの中身をみていこう。</p>

<div class="CodeRay">
  <div class="code"><pre>    outpoint = lambda <span style="color:#080;font-weight:bold">do</span> |rw, val = <span style="color:#069">nil</span>|
      <span style="color:#080;font-weight:bold">case</span> rw
      <span style="color:#080;font-weight:bold">when</span> <span style="color:#A60">:read</span>
        hash = hash256.call(<span style="color:#A60">:read</span>)
        index = uint32.call(<span style="color:#A60">:read</span>)
        <span style="color:#080;font-weight:bold">return</span> { <span style="color:#A60">:hash</span> =&gt; hash, <span style="color:#A60">:index</span> =&gt; index }
      <span style="color:#080;font-weight:bold">when</span> <span style="color:#A60">:write</span>
        hash256.call(<span style="color:#A60">:write</span>, val[<span style="color:#A60">:hash</span>])
        uint32.call(<span style="color:#A60">:write</span>, val[<span style="color:#A60">:index</span>])
      <span style="color:#080;font-weight:bold">end</span>
    <span style="color:#080;font-weight:bold">end</span>

    tx_in = lambda <span style="color:#080;font-weight:bold">do</span> |rw, val = <span style="color:#069">nil</span>|
      <span style="color:#080;font-weight:bold">case</span> rw
      <span style="color:#080;font-weight:bold">when</span> <span style="color:#A60">:read</span>
        previous_output = outpoint.call(<span style="color:#A60">:read</span>)
        signature_script = string.call(<span style="color:#A60">:read</span>)
        sequence = uint32.call(<span style="color:#A60">:read</span>)
        <span style="color:#080;font-weight:bold">return</span> { <span style="color:#A60">:previous_output</span> =&gt; previous_output,
                 <span style="color:#A60">:signature_script</span> =&gt; signature_script, <span style="color:#A60">:sequence</span> =&gt; sequence }
      <span style="color:#080;font-weight:bold">when</span> <span style="color:#A60">:write</span>
        outpoint.call(<span style="color:#A60">:write</span>, val[<span style="color:#A60">:previous_output</span>])
        string.call(<span style="color:#A60">:write</span>, val[<span style="color:#A60">:signature_script</span>])
        uint32.call(<span style="color:#A60">:write</span>, val[<span style="color:#A60">:sequence</span>])
      <span style="color:#080;font-weight:bold">end</span>
    <span style="color:#080;font-weight:bold">end</span>

    tx_out = lambda <span style="color:#080;font-weight:bold">do</span> |rw, val = <span style="color:#069">nil</span>|
      <span style="color:#080;font-weight:bold">case</span> rw
      <span style="color:#080;font-weight:bold">when</span> <span style="color:#A60">:read</span>
        value = uint64.call(<span style="color:#A60">:read</span>)
        pk_script = string.call(<span style="color:#A60">:read</span>)
        <span style="color:#080;font-weight:bold">return</span> { <span style="color:#A60">:value</span> =&gt; value, <span style="color:#A60">:pk_script</span> =&gt; pk_script }
      <span style="color:#080;font-weight:bold">when</span> <span style="color:#A60">:write</span>
        uint64.call(<span style="color:#A60">:write</span>, val[<span style="color:#A60">:value</span>])
        string.call(<span style="color:#A60">:write</span>, val[<span style="color:#A60">:pk_script</span>])
      <span style="color:#080;font-weight:bold">end</span>
    <span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>


<p>tx_inは入力となるトランザクションの情報を含む型である。sequenceは今は使われていないので常にUINT_MAXである。
previous_outputが具体的な前のトランザクションのハッシュと、前のトランザクションの何番目のtx_outに対応するかを含む。
signature_scriptの作成方法は非常にまどろっこしいが後ほどトランザクションの作成の節で説明する。</p>

<p>tx_outはトランザクションの出力先である。valueは出力の額で単位はsatoshi、pk_scriptは公開鍵の「スクリプト」(<a href="https://en.bitcoin.it/wiki/Script">Bitcoin Wiki</a>)である。</p>

<p>Bitcoinは多様な決済手段や多様な電子署名アルゴリズムのサポートを将来的に実現するため、「出力先」の指定方法・電子署名の検証方法はかなりの柔軟性を持った作りになっている。この柔軟性を実現させているのが、「スクリプト」で、簡易的なスタック言語のバイトコードを用いて電子署名の検証を行うようになっている。</p>

<p>しかし現状では、ほとんど定型のスクリプトしか使われていないため、bcwallet.rbではこれのみをサポートすることとする。
（具体的なスクリプトの実行の様子や、これに起因するBitcoinの問題については、<a href="malleability.html">トランザクション展性</a>で解説）</p>

<div class="CodeRay">
  <div class="code"><pre>  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">extract_public_key_hash_from_script</span>(script)
    <span style="color:#777"># OP_DUP OP_HASH160 (public key hash) OP_EQUALVERIFY OP_CHECKSIG</span>
    <span style="color:#080;font-weight:bold">unless</span> script[<span style="color:#00D">0</span>, <span style="color:#00D">3</span>]  == [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">76a914</span><span style="color:#710">'</span></span>].pack(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">H*</span><span style="color:#710">'</span></span>) &amp;&amp;
           script[<span style="color:#00D">23</span>, <span style="color:#00D">2</span>] == [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">88ac</span><span style="color:#710">'</span></span>].pack(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">H*</span><span style="color:#710">'</span></span>) &amp;&amp;
           script.length == <span style="color:#00D">25</span> <span style="color:#080;font-weight:bold">then</span>
      raise <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">unsupported script format</span><span style="color:#710">'</span></span> 
    <span style="color:#080;font-weight:bold">end</span>

    <span style="color:#080;font-weight:bold">return</span> script[<span style="color:#00D">3</span>, <span style="color:#00D">20</span>]
  <span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>


<p>同期が終わった後、BCWalletクラスはNetwork#get_balanceを呼び出してアドレスごとの残高を取得し、最後は画面に出力する。</p>

<div class="CodeRay">
  <div class="code"><pre>  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">get_balance</span>
    balance = {}
    <span style="color:#33B">@keys</span>.each <span style="color:#080;font-weight:bold">do</span> |addr, _|
      balance[addr] = <span style="color:#00D">0</span>
    <span style="color:#080;font-weight:bold">end</span>

    set_spent_for_tx_outs()

    <span style="color:#33B">@data</span>[<span style="color:#A60">:txs</span>].each <span style="color:#080;font-weight:bold">do</span> |tx_hash, tx|
      <span style="color:#33B">@keys</span>.each <span style="color:#080;font-weight:bold">do</span> |addr, key|
        public_key_hash = key.to_public_key_hash

        tx[<span style="color:#A60">:tx_out</span>].each <span style="color:#080;font-weight:bold">do</span> |tx_out|
          <span style="color:#777"># The tx_out was already spent</span>
          <span style="color:#080;font-weight:bold">next</span> <span style="color:#080;font-weight:bold">if</span> tx_out[<span style="color:#A60">:spent</span>]

          <span style="color:#080;font-weight:bold">if</span> extract_public_key_hash_from_script(tx_out[<span style="color:#A60">:pk_script</span>]) == public_key_hash <span style="color:#080;font-weight:bold">then</span>
            balance[addr] += tx_out[<span style="color:#A60">:value</span>]
          <span style="color:#080;font-weight:bold">end</span>
        <span style="color:#080;font-weight:bold">end</span>
      <span style="color:#080;font-weight:bold">end</span>
    <span style="color:#080;font-weight:bold">end</span>

    <span style="color:#080;font-weight:bold">return</span> balance
  <span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>


<p>公開鍵のハッシュが自分の物と一致していてかつ消費されていないトランザクションなら残額に追加する、という単純な処理である。</p>

<p>set_spent_for_tx_outsは、そのtx_outがすでに他のtxで消費されていたら:usedという内部フラグを立てる関数である。</p>

<p>本来であればこのあたりでmerkletreeを見てトランザクションがブロックチェーンに含まれているか否かを判定するべきである。（加筆予定）</p>

<h3 id="トランザクションの作成・電子署名">トランザクションの作成・電子署名</h3>

<p>トランザクションを送信する時は、BCWalletはまずNetwork#sendで送信先や送信元のキー・コインの額などを指定し、その後やはりNetwork#syncする。</p>

<p>この時のNetwork#syncは、@created_transactionのハッシュをinvしてgetdataにtxを返しているという、先に説明した流れを逆側の立場から行っているだけなので、以降の話はNetwork#sendの内部の話に絞る。</p>

<div class="CodeRay">
  <div class="code"><pre>  <span style="color:#777"># </span>
  <span style="color:#777"># コインを指定したアドレスに送る</span>
  <span style="color:#777"># from_key = コインの送信元のキーのオブジェクト（Keyクラスのインスタンス）</span>
  <span style="color:#777"># to_addr  = 受信するアドレスの文字列</span>
  <span style="color:#777"># transaction_fee = 取引手数料</span>
  <span style="color:#777">#</span>
  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">send</span>(from_key, to_addr, amount, transaction_fee = <span style="color:#00D">0</span>)
    to_addr_decoded = <span style="color:#036;font-weight:bold">Key</span>.decode_base58check(to_addr)

    raise <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">invalid address</span><span style="color:#710">&quot;</span></span> <span style="color:#080;font-weight:bold">if</span> to_addr_decoded[<span style="color:#A60">:type</span>] != <span style="color:#A60">:public_key</span>

    public_key_hash = from_key.to_public_key_hash

    set_spent_for_tx_outs()
</pre></div>
</div>


<p>過去のトランザクションの中で、</p>

<ul>
<li>そのアドレスに向けたトランザクションで</li>
<li>未だ使用されていない</li>
</ul>

<p>物を、次々とtx_inに追加していく。これを、送信額として足りるまで続ける。</p>

<div class="CodeRay">
  <div class="code"><pre>    total_satoshis = <span style="color:#00D">0</span>
    tx_in = []
    <span style="color:#33B">@data</span>[<span style="color:#A60">:txs</span>].each <span style="color:#080;font-weight:bold">do</span> |tx_hash, tx|
      <span style="color:#080;font-weight:bold">break</span> <span style="color:#080;font-weight:bold">if</span> total_satoshis &gt;= amount

      matched = <span style="color:#069">nil</span>
      pk_script = <span style="color:#069">nil</span>

      tx[<span style="color:#A60">:tx_out</span>].each_with_index <span style="color:#080;font-weight:bold">do</span> |tx_out, index|
        <span style="color:#080;font-weight:bold">next</span> <span style="color:#080;font-weight:bold">if</span> tx_out[<span style="color:#A60">:spent</span>]

        <span style="color:#080;font-weight:bold">if</span> extract_public_key_hash_from_script(tx_out[<span style="color:#A60">:pk_script</span>]) == public_key_hash <span style="color:#080;font-weight:bold">then</span>
          total_satoshis += tx_out[<span style="color:#A60">:value</span>]
          matched = index
          pk_script = tx_out[<span style="color:#A60">:pk_script</span>]
          <span style="color:#080;font-weight:bold">break</span>
        <span style="color:#080;font-weight:bold">end</span>
      <span style="color:#080;font-weight:bold">end</span>

      <span style="color:#080;font-weight:bold">if</span> matched <span style="color:#080;font-weight:bold">then</span>
        tx_in.push({ <span style="color:#A60">:previous_output</span> =&gt; { <span style="color:#A60">:hash</span> =&gt; tx[<span style="color:#A60">:hash</span>], <span style="color:#A60">:index</span> =&gt; matched },
                     <span style="color:#A60">:signature_script</span> =&gt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#710">'</span></span>,
                     <span style="color:#A60">:sequence</span> =&gt; ((<span style="color:#00D">1</span> &lt;&lt; <span style="color:#00D">32</span>) - <span style="color:#00D">1</span>),

                     <span style="color:#777"># 送信データには含まれないが、電子署名の作成に使う</span>
                     <span style="color:#A60">:pk_script</span> =&gt; pk_script })
      <span style="color:#080;font-weight:bold">end</span>
    <span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>


<p>余った額が「おつり」（payback）として自分宛てのtx_outに追加される。pk_scriptは先に説明した通りである。</p>

<div class="CodeRay">
  <div class="code"><pre>    payback = total_satoshis - amount - transaction_fee

    raise <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">you don't have enough balance to pay</span><span style="color:#710">&quot;</span></span> <span style="color:#080;font-weight:bold">unless</span> payback &gt;= <span style="color:#00D">0</span>

    prefix = [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">76a914</span><span style="color:#710">'</span></span>].pack(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">H*</span><span style="color:#710">'</span></span>) <span style="color:#777"># OP_DUP OP_HASH160 [length of the address]</span>
    postfix = [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">88ac</span><span style="color:#710">'</span></span>].pack(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">H*</span><span style="color:#710">'</span></span>)  <span style="color:#777"># OP_EQUALVERIFY OP_CHECKSIG</span>

    tx_out = [{ <span style="color:#A60">:value</span> =&gt; amount,  <span style="color:#A60">:pk_script</span> =&gt; (prefix + to_addr_decoded[<span style="color:#A60">:data</span>] + postfix) },
              { <span style="color:#A60">:value</span> =&gt; payback, <span style="color:#A60">:pk_script</span> =&gt; (prefix + public_key_hash + postfix) }]

    <span style="color:#33B">@created_transaction</span> = {
      <span style="color:#A60">:command</span> =&gt; <span style="color:#A60">:tx</span>,

      <span style="color:#A60">:version</span> =&gt; <span style="color:#00D">1</span>,
      <span style="color:#A60">:tx_in</span> =&gt; tx_in,
      <span style="color:#A60">:tx_out</span> =&gt; tx_out,
      <span style="color:#A60">:lock_time</span> =&gt; <span style="color:#00D">0</span>
    }
</pre></div>
</div>


<p>ここから、電子署名の構築に入るが、非常に分かりづらい上に資料も発見しづらいので注意する。Bitcoin Wikiでは<a href="https://en.bitcoin.it/wiki/OP_CHECKSIG">OP_CHECKSIG</a>に唯一書いてあるが読みづらい。</p>

<div class="CodeRay">
  <div class="code"><pre><span style="color:#777"># ここまでで、電子署名抜きのデータを作成したので電子署名を以下で生成する。</span>

    signatures = []

    tx_in.each_with_index <span style="color:#080;font-weight:bold">do</span> |tx_in_elm, i|
  <span style="color:#777"># 元のデータが壊れないように必要最小限の深さだけコピー</span>
      duplicated = <span style="color:#33B">@created_transaction</span>.dup
      duplicated[<span style="color:#A60">:tx_in</span>] = duplicated[<span style="color:#A60">:tx_in</span>].dup
      duplicated[<span style="color:#A60">:tx_in</span>][i] = duplicated[<span style="color:#A60">:tx_in</span>][i].dup
</pre></div>
</div>


<p>電子署名の対象となるデータは、以下の手順で構築された、「特殊な」トランザクション全体のハッシュ(Hash256)である。</p>

<p>まず、署名したい部分のtx_inのsignature_scriptを、対応するtx_outの:pk_scriptで埋め、それ以外のsignature_scriptは全て空欄とする。なお、各signature_scriptのstringの先頭の、var_intも連動して0になるので注意する。<a href="https://en.bitcoin.it/wiki/OP_CHECKSIG">Bitcoin WikiのOP_CHECKSIGの項目</a>にArmory（というBitcoinクライアント）の作者が描いた図がある。</p>

<div class="CodeRay">
  <div class="code"><pre>  <span style="color:#777"># 対応するtx_outの:pk_scriptで埋める（他のtx_inのsignature_scriptは空欄）</span>
      duplicated[<span style="color:#A60">:tx_in</span>][i][<span style="color:#A60">:signature_script</span>] = tx_in_elm[<span style="color:#A60">:pk_script</span>]

      serialize_message(duplicated)

  <span style="color:#777"># @payloadにシリアライズされたデータが入る</span>
</pre></div>
</div>


<p>さらにそこにハッシュ種別コード（意味についてはWiki参照のこと）を末尾に<strong>4バイト</strong>で付加し、全体でHash256を取る。</p>

<div class="CodeRay">
  <div class="code"><pre>      <span style="color:#777"># hash256 includes type code field (see the figure in the URL above)</span>
      verified_str = <span style="color:#036;font-weight:bold">Key</span>.hash256(<span style="color:#33B">@payload</span> + [<span style="color:#00D">1</span>].pack(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">V</span><span style="color:#710">'</span></span>))
</pre></div>
</div>


<p>それをはじめて手元の鍵で電子署名する。</p>

<div class="CodeRay">
  <div class="code"><pre>      signatures.push from_key.sign(verified_str)
    <span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>


<p>しかし、signature_scriptも同様にスクリプトシステムの一部なので、普通に作成したsignatureを貼るだけではダメである。さらに、冷静になって思い出して欲しいが、他ノードは未だあなたの公開鍵のハッシュしか知らないのであり、公開鍵本体も必要である。</p>

<p>これらを、＜電子署名+種別コード（<strong>今度はここでは1バイト</strong>）＞＜公開鍵＞の順でsignature_script格納するが、それぞれの頭に長さを付与しなければならない。そしてこれはvar_int型では<strong>ない</strong>。また、電子署名＋種別コード1バイトなので、signature.lengthに1を足している。</p>

<div class="CodeRay">
  <div class="code"><pre>    signatures.each_with_index <span style="color:#080;font-weight:bold">do</span> |signature, i|
      <span style="color:#33B">@created_transaction</span>[<span style="color:#A60">:tx_in</span>][i][<span style="color:#A60">:signature_script</span>] =
        [signature.length + <span style="color:#00D">1</span>].pack(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">C</span><span style="color:#710">'</span></span>) + signature + [<span style="color:#00D">1</span>].pack(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">C</span><span style="color:#710">'</span></span>) +
        [from_key.to_public_key.length].pack(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">C</span><span style="color:#710">'</span></span>) + from_key.to_public_key
    <span style="color:#080;font-weight:bold">end</span>

    <span style="color:#33B">@status</span> = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#710">'</span></span>

    <span style="color:#080;font-weight:bold">return</span>
  <span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>


<p>ようやっとこれで電子署名が作成できた。あとは、これをinv→getdata→txのやりとりで送信すれば、あなたのトランザクションは送信できたということになる。</p>

<h3 id="まとめ">まとめ</h3>

<p>ここまでを通して、Bitcoinは、実際に実装するにあたっても決して難しい技術ではないという事が分かったかと思う。</p>

<p>しかしながら、どのクライアントにしても、Bitcoinクライアントの使い勝手は洗練されているとは言い難いのが実情であるし、ネットワーク通信部分はほとんどSatoshi Client系の実装（Bitcoin-Qt, bitcoind, Armory, Electrum?など）系の実装かbitcoinj系の実装（MultiBit, Bitcoin Walletなど）の二つのみが使われていて、実装にしろ資料・仕様書にしろ全く出揃っていないという現実がある。</p>

<p>しかし、これは裏を返せばチャンスではないだろうか？是非これを読まれたやる気のある方は、使いやすくきれいなBitcoinクライアントの実装でBitcoin界を改革してほしいと思う。</p>

<p>「<a href="malleability.html">トランザクション展性とは</a>」につづく</p>

			</div>
			<div id="menu">
				<ul>
					<li><a href="index.html">トップ</a></li>
<li><a href="design.html">Bitcoinの仕組み</a></li>
<li><a href="comparison.html">Bitcoinウォレットの比較</a></li>
<li><a href="detail.html">Bitcoinの細部</a></li>
<li><a href="implement.html">Bitcoinウォレットを実装する</a></li>
<li><a href="malleability.html">トランザクション展性とは</a></li>
<li><a href="derivatives.html">Bitcoinの派生通貨</a></li>
<li><a href="history.html">Bitcoinの歴史</a></li>
<li><a href="links.html">リンク集</a></li>
</ul><ul>
<li><a href="intro.html">はじめに</a></li>
<li><a href="sitemap.html">サイトの構成</a></li>
<li><a href="background.html">必要な予備知識</a></li>
				</ul>
				<ul>
					<li><a href="http://peryaudo.org/">筆者紹介</a></li>
					<li><a href="http://bitcoin.peryaudo.org/index.rdf">RSS 2.0</a></li>
				</ul>
				<ul>
					<li><a href="https://github.com/peryaudo/bitcoin.peryaudo.org">このページの編集を提案</a></li>
				</ul>
			</div>
			<div id="footer">
				<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="クリエイティブ・コモンズ・ライセンス" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a><br /><a xmlns:cc="http://creativecommons.org/ns#" href="http://bitcoin.peryaudo.org/" property="cc:attributionName" rel="cc:attributionURL">peryaudo</a> 作『<span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">ビットコインの仕組み</span>』は<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">クリエイティブ・コモンズ 表示 - 継承 4.0 国際 ライセンス</a>で提供されています。
			</div>
		</div>
	</body>
</html>
